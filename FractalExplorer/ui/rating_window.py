"""
Rating Window for Fractal Selection

This module provides a clean, user-friendly interface for selecting preferred fractals
from a 4-option grid. Much simpler than numeric rating - just click the best one!
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from PIL import Image, ImageTk
import threading
from pathlib import Path
from typing import List, Optional, Callable, Dict, Any
import logging

logger = logging.getLogger(__name__)


class RatingWindow:
    """
    Main window for fractal preference rating.
    
    Displays 4 fractal thumbnails in a grid and allows the user to select
    their preferred one. Tracks statistics and provides user feedback.
    """
    
    def __init__(self, 
                 title: str = "Fractal Genesis - Select Your Favorite",
                 window_size: tuple = (800, 650),
                 thumbnail_size: tuple = (300, 300)):
        """
        Initialize the rating window.
        
        Args:
            title: Window title
            window_size: Main window dimensions (width, height)
            thumbnail_size: Size of individual fractal thumbnails
        """
        self.title = title
        self.window_size = window_size
        self.thumbnail_size = thumbnail_size
        
        # Selection callback
        self.on_selection_callback: Optional[Callable[[int], None]] = None
        
        # Current session data
        self.current_images: List[Optional[Path]] = [None, None, None, None]
        self.current_metadata: List[Optional[Dict[str, Any]]] = [None, None, None, None]
        self.selection_count = 0
        self.session_stats = {'total_selections': 0, 'current_generation': 1}
        
        # UI elements
        self.root: Optional[tk.Tk] = None
        self.image_buttons: List[tk.Button] = []
        self.image_labels: List[tk.Label] = []
        self.photo_images: List[Optional[ImageTk.PhotoImage]] = []
        self.status_label: Optional[tk.Label] = None
        self.progress_var: Optional[tk.StringVar] = None
        self.generation_var: Optional[tk.StringVar] = None
        
        self.is_running = False
        self.selected_option = None
        
        # Thread safety
        self.selection_lock = threading.Lock()
        
    def setup_window(self):
        """Initialize the main window and UI components."""
        self.root = tk.Tk()
        self.root.title(self.title)
        self.root.geometry(f\"{self.window_size[0]}x{self.window_size[1]}\")\n        self.root.resizable(True, True)\n        \n        # Configure grid weights for responsive layout\n        self.root.grid_rowconfigure(1, weight=1)\n        self.root.grid_columnconfigure(0, weight=1)\n        \n        # Create UI components\n        self._create_header()\n        self._create_image_grid()\n        self._create_control_panel()\n        self._create_status_bar()\n        \n        # Set up event handlers\n        self.root.protocol(\"WM_DELETE_WINDOW\", self.on_window_close)\n        \n        # Center window on screen\n        self.root.update_idletasks()\n        self._center_window()\n        \n        logger.info(\"Rating window initialized\")\n    \n    def _create_header(self):\n        \"\"\"Create the header section with title and generation info.\"\"\"\n        header_frame = ttk.Frame(self.root)\n        header_frame.grid(row=0, column=0, sticky=\"ew\", padx=10, pady=5)\n        header_frame.grid_columnconfigure(0, weight=1)\n        \n        # Title\n        title_label = ttk.Label(header_frame, \n                               text=\"Choose Your Favorite Fractal\",\n                               font=(\"Arial\", 16, \"bold\"))\n        title_label.grid(row=0, column=0, sticky=\"w\")\n        \n        # Generation info\n        self.generation_var = tk.StringVar(value=\"Generation: 1\")\n        gen_label = ttk.Label(header_frame, textvariable=self.generation_var)\n        gen_label.grid(row=0, column=1, sticky=\"e\")\n        \n        # Instructions\n        instructions = ttk.Label(header_frame,\n                                text=\"Click on the fractal you find most visually interesting\",\n                                font=(\"Arial\", 10))\n        instructions.grid(row=1, column=0, columnspan=2, sticky=\"w\", pady=(5, 0))\n    \n    def _create_image_grid(self):\n        \"\"\"Create the 2x2 grid of fractal images.\"\"\"\n        grid_frame = ttk.Frame(self.root)\n        grid_frame.grid(row=1, column=0, sticky=\"nsew\", padx=10, pady=10)\n        \n        # Configure grid weights\n        for i in range(2):\n            grid_frame.grid_rowconfigure(i, weight=1)\n            grid_frame.grid_columnconfigure(i, weight=1)\n        \n        self.image_buttons = []\n        self.photo_images = [None, None, None, None]\n        \n        positions = [(0, 0), (0, 1), (1, 0), (1, 1)]\n        \n        for i, (row, col) in enumerate(positions):\n            # Create a frame for each image\n            img_frame = ttk.LabelFrame(grid_frame, text=f\"Option {i+1}\", padding=\"5\")\n            img_frame.grid(row=row, column=col, sticky=\"nsew\", padx=5, pady=5)\n            img_frame.grid_rowconfigure(0, weight=1)\n            img_frame.grid_columnconfigure(0, weight=1)\n            \n            # Create image button\n            img_button = tk.Button(img_frame,\n                                  text=f\"Loading...\\nOption {i+1}\",\n                                  width=25, height=15,\n                                  command=lambda idx=i: self.on_image_selected(idx),\n                                  cursor=\"hand2\")\n            img_button.grid(row=0, column=0, sticky=\"nsew\")\n            \n            self.image_buttons.append(img_button)\n    \n    def _create_control_panel(self):\n        \"\"\"Create control buttons and options.\"\"\"\n        control_frame = ttk.Frame(self.root)\n        control_frame.grid(row=2, column=0, sticky=\"ew\", padx=10, pady=5)\n        control_frame.grid_columnconfigure(0, weight=1)\n        \n        # Button frame\n        button_frame = ttk.Frame(control_frame)\n        button_frame.grid(row=0, column=0)\n        \n        # Skip button (if user doesn't like any)\n        skip_button = ttk.Button(button_frame,\n                               text=\"Skip (None Appeal to Me)\",\n                               command=self.on_skip_selection)\n        skip_button.grid(row=0, column=0, padx=5)\n        \n        # Save current images button\n        save_button = ttk.Button(button_frame,\n                               text=\"Save These Images\",\n                               command=self.on_save_images)\n        save_button.grid(row=0, column=1, padx=5)\n        \n        # Settings button\n        settings_button = ttk.Button(button_frame,\n                                   text=\"Settings\",\n                                   command=self.on_show_settings)\n        settings_button.grid(row=0, column=2, padx=5)\n    \n    def _create_status_bar(self):\n        \"\"\"Create status bar with progress information.\"\"\"\n        status_frame = ttk.Frame(self.root)\n        status_frame.grid(row=3, column=0, sticky=\"ew\", padx=10, pady=5)\n        status_frame.grid_columnconfigure(1, weight=1)\n        \n        # Progress info\n        self.progress_var = tk.StringVar(value=\"Ready to start...\")\n        self.status_label = ttk.Label(status_frame, textvariable=self.progress_var)\n        self.status_label.grid(row=0, column=0, sticky=\"w\")\n        \n        # Selection count\n        count_label = ttk.Label(status_frame, text=\"Selections: 0\")\n        count_label.grid(row=0, column=1, sticky=\"e\")\n        self.count_label = count_label\n    \n    def _center_window(self):\n        \"\"\"Center the window on the screen.\"\"\"\n        self.root.update_idletasks()\n        width = self.root.winfo_width()\n        height = self.root.winfo_height()\n        pos_x = (self.root.winfo_screenwidth() // 2) - (width // 2)\n        pos_y = (self.root.winfo_screenheight() // 2) - (height // 2)\n        self.root.geometry(f\"{width}x{height}+{pos_x}+{pos_y}\")\n    \n    def load_images(self, image_paths: List[Optional[Path]], metadata: List[Optional[Dict[str, Any]]] = None):\n        \"\"\"\n        Load four fractal images into the selection grid.\n        \n        Args:\n            image_paths: List of 4 image file paths (can contain None for empty slots)\n            metadata: Optional metadata for each image\n        \"\"\"\n        if len(image_paths) != 4:\n            raise ValueError(\"Must provide exactly 4 image paths\")\n            \n        self.current_images = image_paths.copy()\n        self.current_metadata = metadata if metadata else [None] * 4\n        \n        # Load images in separate thread to avoid blocking UI\n        threading.Thread(target=self._load_images_async, daemon=True).start()\n    \n    def _load_images_async(self):\n        \"\"\"Load images asynchronously to avoid blocking the UI thread.\"\"\"\n        try:\n            for i, img_path in enumerate(self.current_images):\n                if img_path and img_path.exists():\n                    # Load and resize image\n                    with Image.open(img_path) as img:\n                        # Resize while maintaining aspect ratio\n                        img.thumbnail(self.thumbnail_size, Image.Resampling.LANCZOS)\n                        \n                        # Create a new image with fixed size (pad if necessary)\n                        display_img = Image.new('RGB', self.thumbnail_size, (40, 40, 40))\n                        paste_x = (self.thumbnail_size[0] - img.width) // 2\n                        paste_y = (self.thumbnail_size[1] - img.height) // 2\n                        display_img.paste(img, (paste_x, paste_y))\n                        \n                        # Convert to PhotoImage\n                        photo = ImageTk.PhotoImage(display_img)\n                        \n                        # Update UI in main thread\n                        self.root.after(0, self._update_image_button, i, photo)\n                else:\n                    # Empty slot\n                    self.root.after(0, self._update_image_button, i, None)\n                    \n        except Exception as e:\n            logger.error(f\"Error loading images: {e}\")\n            self.root.after(0, self._show_loading_error)\n    \n    def _update_image_button(self, index: int, photo: Optional[ImageTk.PhotoImage]):\n        \"\"\"Update an image button with the loaded photo (runs in main thread).\"\"\"\n        button = self.image_buttons[index]\n        \n        if photo:\n            self.photo_images[index] = photo  # Keep reference to prevent GC\n            button.config(image=photo, text=\"\", compound=tk.CENTER)\n            button.config(relief=tk.RAISED, bg=\"white\")\n        else:\n            button.config(image=\"\", text=f\"No Image\\nOption {index+1}\", compound=tk.CENTER)\n            button.config(relief=tk.FLAT, bg=\"#f0f0f0\")\n    \n    def _show_loading_error(self):\n        \"\"\"Show an error message for image loading failures.\"\"\"\n        messagebox.showerror(\"Image Loading Error\", \n                           \"Failed to load some fractal images. Please try again.\")\n    \n    def on_image_selected(self, index: int):\n        \"\"\"\n        Handle user selection of a fractal image.\n        \n        Args:\n            index: Index of selected image (0-3)\n        \"\"\"\n        with self.selection_lock:\n            if not self.is_running:\n                return\n                \n            self.selected_option = index\n            self.selection_count += 1\n            self.session_stats['total_selections'] += 1\n            \n            # Visual feedback\n            self._highlight_selection(index)\n            \n            # Update status\n            self.progress_var.set(f\"Selected Option {index+1} - Processing...\")\n            self.count_label.config(text=f\"Selections: {self.selection_count}\")\n            \n            # Call the callback if set\n            if self.on_selection_callback:\n                threading.Thread(target=lambda: self.on_selection_callback(index), daemon=True).start()\n    \n    def _highlight_selection(self, selected_index: int):\n        \"\"\"Provide visual feedback for the selected option.\"\"\"\n        for i, button in enumerate(self.image_buttons):\n            if i == selected_index:\n                button.config(relief=tk.SUNKEN, bg=\"#90EE90\")  # Light green\n            else:\n                button.config(relief=tk.RAISED, bg=\"white\")\n    \n    def on_skip_selection(self):\n        \"\"\"Handle skip selection (user doesn't like any of the options).\"\"\"\n        with self.selection_lock:\n            if not self.is_running:\n                return\n                \n            self.selected_option = -1  # Special value for skip\n            self.progress_var.set(\"Skipped - Generating new options...\")\n            \n            if self.on_selection_callback:\n                threading.Thread(target=lambda: self.on_selection_callback(-1), daemon=True).start()\n    \n    def on_save_images(self):\n        \"\"\"Allow user to save current fractal images.\"\"\"\n        save_dir = filedialog.askdirectory(title=\"Choose directory to save images\")\n        if save_dir:\n            threading.Thread(target=self._save_images_async, args=(save_dir,), daemon=True).start()\n    \n    def _save_images_async(self, save_dir: str):\n        \"\"\"Save current images to directory.\"\"\"\n        try:\n            save_path = Path(save_dir)\n            saved_count = 0\n            \n            for i, img_path in enumerate(self.current_images):\n                if img_path and img_path.exists():\n                    dest_path = save_path / f\"fractal_option_{i+1}_{img_path.name}\"\n                    dest_path.write_bytes(img_path.read_bytes())\n                    saved_count += 1\n            \n            self.root.after(0, lambda: messagebox.showinfo(\"Images Saved\", \n                                                          f\"Saved {saved_count} images to {save_dir}\"))\n        except Exception as e:\n            self.root.after(0, lambda: messagebox.showerror(\"Save Error\", f\"Failed to save images: {e}\"))\n    \n    def on_show_settings(self):\n        \"\"\"Show settings dialog.\"\"\"\n        # For now, just show current statistics\n        stats_text = f\"\"\"Current Session Statistics:\n        \nTotal Selections: {self.session_stats['total_selections']}\nCurrent Generation: {self.session_stats['current_generation']}\nThis Round: {self.selection_count}\n        \"\"\"\n        messagebox.showinfo(\"Session Statistics\", stats_text)\n    \n    def update_generation(self, generation: int):\n        \"\"\"Update the current generation display.\"\"\"\n        self.session_stats['current_generation'] = generation\n        if self.generation_var:\n            self.generation_var.set(f\"Generation: {generation}\")\n    \n    def set_selection_callback(self, callback: Callable[[int], None]):\n        \"\"\"Set the callback function for when user makes a selection.\"\"\"\n        self.on_selection_callback = callback\n    \n    def show_and_wait_for_selection(self) -> int:\n        \"\"\"\n        Show the window and wait for user selection.\n        \n        Returns:\n            Index of selected option (0-3) or -1 for skip\n        \"\"\"\n        self.is_running = True\n        self.selected_option = None\n        \n        while self.selected_option is None and self.is_running:\n            if self.root:\n                try:\n                    self.root.update()\n                except tk.TclError:\n                    # Window was closed\n                    self.is_running = False\n                    break\n        \n        return self.selected_option if self.selected_option is not None else -1\n    \n    def reset_selection(self):\n        \"\"\"Reset the selection state for next round.\"\"\"\n        self.selected_option = None\n        self.progress_var.set(\"Choose your favorite fractal...\")\n        \n        # Reset button appearances\n        for button in self.image_buttons:\n            button.config(relief=tk.RAISED, bg=\"white\")\n    \n    def on_window_close(self):\n        \"\"\"Handle window close event.\"\"\"\n        self.is_running = False\n        if self.root:\n            self.root.quit()\n            self.root.destroy()\n    \n    def start(self):\n        \"\"\"Start the rating window application.\"\"\"\n        if not self.root:\n            self.setup_window()\n        \n        self.is_running = True\n        self.root.mainloop()\n    \n    def stop(self):\n        \"\"\"Stop the rating window application.\"\"\"\n        self.is_running = False\n        if self.root:\n            self.root.after(0, self.on_window_close)
